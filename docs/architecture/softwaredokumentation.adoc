= Softwaredokumentation: {project-name}
Sebastian Treß <s86372@htw-dresden.de>; Niklas Benjamin Große <niklasbenjamin.grosse@stud.htw-dresden.de>
{localdatetime}
include::../_includes/default-attributes.inc.adoc[]

== Allgemeine Informationen

Die Softwaredokumentation beinhaltet die Beschreibung aller Klassen bzw. aller Dokumente und
die darin enthaltenen Funktionen. Zusätzlich dazu, sind in jedem Python-Dokument die
entsprechenden Funktionen und Methoden kommentiert.

== Frontend

++++
include::{htmlsdir}/Frontend_Documentation_Components.html[]
++++

== Backend

=== Benutzerinteraktion mittels REST-API

Die Benutzeroberfläche der Progressive Web App (PWA) kommuniziert mit dem Backend über eine RESTful API. Die API stellt definierte HTTP-Endpunkte bereit, über die CRUD-Operationen (Create, Read, Update, Delete) auf den Turnierdaten durchgeführt werden können.

Der Datenaustausch erfolgt über das JSON-Format. Sämtliche API-Aufrufe sind zustandslos und orientieren sich an den gängigen REST-Konventionen. Dadurch wird eine klare Trennung zwischen dem Frontend und dem Backend gewährleistet.

Die REST-API bildet die zentrale Schnittstelle für alle Funktionen wie Turniererstellung, Teamverwaltung, Ergebniserfassung und Auswertung.

=== Endpunkte der REST-API

Die wichtigsten API-Endpunkte sind in den folgenden Tabellen zusammengefasst. https://github.com/sebastiantress03/Projekt-Software-Engineering/blob/main/src/backend/data/documentation/backend%20API%20documentation.html[Dokumentation backend.py] +

:sectnums!:
==== POST-Endpunkte

[cols="2,3,2", options="header"]
|===
| API-Endpunkt |  Beschreibung des Endpunktes | Backendfunktion
| `/tournament/` | Erstellung und Speicherung eines Turnierplans in eine Datenbank | `generate_tournament()`
|===

==== GET-Endpunkte

[cols="2,3,2", options="header"]
|===
| API-Endpunkt | Beschreibung des Endpunktes | Backendfunktion
| `/tournaments/` | Lade existierende Turniernamen aus der Datenbank. | `get_tournaments()`
| `/tournaments/{tournamentID}` | Übermittelt existierenden Turnierplan aus der Datenbank, indem die TurnierID, als String, des Turniers das geladen werden soll mit übergeben wird. | `get_match_plan(tournamentID: str)`
| `/tournaments/match_plan/{matchID}` | Holt aktuelle Spielstand aus der Datenbank mittels der übergabe der SpielID als String. |  `get_match(matchID: str)`
| `/tournaments/match_plan/match_changes/{matchID}` | Holt alle Änderungen, die an einem Spiel vorgenommen wurden, anhand der übergebenen Spiel-ID als String. | `get_match_result_changes(matchID: str)`
|===

==== PUT-Endpunkte
[cols="2,3,2", options="header"]
|===
| API-Endpunkt | Beschreibung des Endpunktes | Backendfunktion
| `/tournaments/match_plan/match/{matchID}` | Ändern von einzelnen Spielständen in der Datenbank. Die Adressierung des Spiels erfolgt über die SpielID als String welche mitgegeben wir. | `change_match_result(matchID: str, match_result: Match)`
| `/tournaments/match_plan/team/{tournamentID}` | Ändern der Namen von einzelnen Teams in der Datenbank. Die Adressierung des Team erfolgt über die TurnierID als String, welche mitgegeben wir damit zunächst überprüft werden kann ob in dem Turnier bereits ein Team mit dem Namen bereits existiert. | `change_team_name(tournamentID: str, new_team_name: TeamUpdate)`
|===

==== DELETE-Endpunkte
[cols="2,3,2", options="header"]
|===
| API-Endpunkt | Beschreibung des Endpunktes | Backendfunktion
| `/tournaments/delete_plan/{tournamentID}` | Das Turnier wird aus der Datenbank gelöscht mir den Dazugehörigen Spielständen und Leistungsgruppen. Dafür wird die TurnierID mit übergeben. |  `delete_tournament(tournamentID: str)`
|===

==== Implementierung der REST-API
Die REST-API des Backends ist mit FastAPI implementiert, einem modernen und performanten Python-Framework für die Entwicklung von Web-APIs. FastAPI bietet integrierte Unterstützung für asynchrone Verarbeitung, automatische Generierung von OpenAPI-Spezifikationen sowie Validierung und Dokumentation von Eingabe- und Ausgabeparametern.

Die API ist modular aufgebaut und nutzt verschiedene Endpunkte zur Bereitstellung der Funktionalität rund um die Verwaltung von Turnieren, Spielplänen und Spielständen. Die Datenzugriffsschicht wurde individuell als eigene Klasse *DatabaseRequests* implementiert, um die Kommunikation mit der Datenbank flexibel und übersichtlich zu gestalten.

FastAPI-Middleware wie *CORSMiddleware* sorgt für die flexible Steuerung von Zugriffsrechten, um Frontend-Anwendungen den Zugriff auf die API zu ermöglichen.

Beispiel: API-Endpunkt zur Erstellung eines Turniers
[source,python]
----
from fastapi import FastAPI, HTTPException
from data.apiClasses.apiClasses import *
from database_request import DatabaseRequests
from data.turnierplangenerator_4 import return_plan

api = FastAPI()
data_request = DatabaseRequests()

@api.get("/tournaments/")
def get_tournaments():
    """
    Gibt alle existierenden Turniere aus der Datenbank zurück.

    Rückgabewert:
        - JSON-Objekt mit dem Schlüssel "tournaments":
            - Eine Liste von Turnieren mit je:
                - "id" (int): Turnier-ID
                - "name" (str): Name des Turniers

    Fehler:
        - HTTP 500: Datenbankfehler beim Abfragen von Daten.
    """
    # Funktion erhalten der existierenden Turniere
    tournaments = data_request.get_existing_tournaments()

    return {"tournaments": tournaments}
----

==== Mögliche Fehlermeldungen und Statuscodes
[cols="1,2,3", options="header"]
|===
| Fehlercode | Ursache | Kontext / Beschreibung

| 400 Bad Request | Ungültige Eingabedaten | - Ungültige `tournamentID` oder `matchID` bei GET-/PUT-Anfragen +
- Ungültige `teamID` bei Teamnamen-Änderung

| 500 Internal Server Error | Datenbankfehler oder unerwartete Fehler | - Fehler beim Hinzufügen, Ändern, Löschen oder Abfragen von Daten in der Datenbank +
- Keine Daten gefunden (z.B. Spiel nicht existent) +
- Allgemeine Serverfehler bei API-Aufrufen
|===
[cols="2", options="header"]
|===
| Statuscode | Bedeutung 
| 200 OK | Erfolgreiche Verarbeitung der Anfrage
|===
:sectnums:

++++
include::{htmlsdir}/backend_py_documentation.html[]
++++

// TODO Backend Funktionen
=== API Klassen

:sectnums!:
==== ReturnMatchOption

[cols="1,1,2,3", options="header"]
|===
| Variabel | Datentyp | validator Bedingung | Beschreibung 
| TRUE     | Enum     | "true" oder "false" als String | Gibt an, ob Rückspiele zurückgegeben werden
| FALSE    | Enum     | "true" oder "false" als String | Gibt an, dass nur Hinspiele zurückgegeben werden
|===
==== GenerateTournament

[cols="1,1,2,3", options="header"]
|===
| Variabel    | Datentyp          | validator Bedingung                             | Beschreibung 
| name        | str               | keine                                          | Name des Turniers
| num_fields  | int               | Mindestens 1 und maximal 5                      | Anzahl der Spielfelder
| return_match| ReturnMatchOption  | "true" oder "false" als String                  | Gibt an, ob Rückspiele mit eingeplant werden
| start       | str               | Format "HH:MM"                                  | Uhrzeit des Turnierstarts
| period      | int               | Zwischen 0 und 60 Minuten                        | Dauer eines Spiels in Minuten
| warm_up     | int               | Zwischen 0 und 60 Minuten                        | Aufwärmzeit am Anfang in Minuten
| num_breaks  | int               | Mindestens 0                                    | Anzahl der Pausen im Turnier
| break_length| Optional[List[int]]| Werte zwischen 1 und 60, Länge = num_breaks    | Längen der Pausen in Minuten
| break_times | Optional[List[str]]| Format "HH:MM", Länge = num_breaks              | Uhrzeiten der Pausen
| stage_name  | List[str]         | Besteht aus Strings                             | Namen der Leistungsgruppen
| num_teams   | List[int]         | Besteht aus Integern                            | Teamanzahl je Leistungsgruppe
|===

==== Match

[cols="1,1,2,3", options="header"]
|===
| Variabel    | Datentyp | validator Bedingung        | Beschreibung 
| score_team1 | int      | Muss >= 0                  | Punkte von Team 1
| score_team2 | int      | Muss >= 0                  | Punkte von Team 2
| time_change | str      | Format "HH:MM"             | Uhrzeit der Ergebnisänderung
|===

==== TournamentPlan

[cols="1,1,2,3", options="header"]
|===
| Variabel | Datentyp | validator Bedingung | Beschreibung 
| Variabel     | Datentyp | validator Bedingung           | Beschreibung 
| game_id      | int      | >= 1                         | Eindeutige Spielnummer
| field_number | int      | 1 bis 5                      | Spielfeldnummer
| team1_id     | int      | >= 0                        | ID von Team 1
| team2_id     | int      | >= 0                        | ID von Team 2
| referee_id   | int      | >= 0                        | ID des Schiedsrichters
| team1        | str      | Muss ein String sein         | Bezeichnung Team 1 (Leistungsgruppe + Nummer)
| team2        | str      | Muss ein String sein         | Bezeichnung Team 2
| referee      | str      | Muss ein String sein         | Name des Schiedsrichters
| stage_name   | str      | Muss ein String sein         | Leistungsgruppenname
| score_team1  | int      | >= 0                        | Punkte Team 1
| score_team2  | int      | >= 0                        | Punkte Team 2
| time_of_game | str      | Format "HH:MM"               | Spielzeit
|===

==== TeamUpdate

[cols="1,1,2,3", options="header"]
|===
| Variabel | Datentyp | validator Bedingung | Beschreibung 
| team_id  | int      | Muss Integer sein      | Eindeutige Team-ID
| new_name | str      | Muss String sein       | Neuer Teamname
|===

=== Database Request
++++
include::{htmlsdir}/database_request_py_documentation.html[]
++++


=== Server
++++
include::{htmlsdir}/server_py_documentation.html[]
++++

=== Turnierplangererator
++++
include::{htmlsdir}/turnierplangenerator_py_documentation.html[]
++++

=== Turnierüberarbeitung
++++
include{htmlsdir}/turnierueberarbeitung_py_documentation.html[]
++++

:sectnums:

== Datenbank

Die Anwendung verwendet eine SQLite-Datenbank zur persistenten Speicherung aller relevanten Daten des Turnierverwaltungssystems. Die Datenbankstruktur umfasst mehrere Tabellen:

- *Turnier*: Speicherung der Turnierinformationen (Bezeichnung, Spieldauer, Anzahl der Teams).
- *Leistungsgruppen*: Verwaltung der Leistungsgruppen mit zugehöriger Teamanzahl.
- *Team*: Zuordnung der Teams zu Turnieren und Leistungsgruppen.
- *Ergebnisse*: Speicherung der Spielergebnisse inkl. Teams, Schiedsrichter, Spielfeld und Uhrzeit.
- *Änderungen*: Protokollierung von Änderungen an Spielergebnissen.

Die Datenbankdatei wird im Verzeichnis `data/db/vtDatabase.db` abgelegt. Beim Start der Anwendung wird überprüft, ob die Datenbank existiert, andernfalls wird sie automatisch initialisiert und die Tabellen werden angelegt.

Der Zugriff auf die Datenbank erfolgt über die zentrale `Server`-Klasse in Python. Diese kapselt alle Datenbankoperationen und stellt zwei Hauptmethoden bereit:

* `query()`: Führt Leseabfragen (SELECT) aus und liefert die Ergebnisse als Liste von Datensätzen zurück.
* `execute()`: Führt Änderungsoperationen (INSERT, UPDATE, DELETE) aus und übernimmt automatisch das Commit.

Zur Gewährleistung der referenziellen Integrität werden Fremdschlüsselbeschränkungen mittels `PRAGMA foreign_keys = ON` aktiviert.

Da SQLite keine serverbasierte Datenbank ist, eignet sich diese Lösung insbesondere für kleine bis mittelgroße Turnieranwendungen, bei denen Einfachheit, Portabilität und geringer Wartungsaufwand im Vordergrund stehen.


=== Entity-Relationship-Modell

Das Entity-Relationship-Modell definiert die Datenbankstruktur zur Verwaltung der Turnierdaten. Es beschreibt die Entitäten, deren Attribute sowie die Beziehungen zwischen den einzelnen Tabellen und dient als Grundlage für die Implementierung der Datenzugriffsschicht.

image::ERM-Datenbank_Software-Engineering.jpg[]
